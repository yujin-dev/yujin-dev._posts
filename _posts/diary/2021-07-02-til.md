---
title: "21.07.01"
category: "til"
---
## sub query 적용 비교
postgresql에서 필터를 적용한 쿼리를 실행할 때 서브 쿼리가 포함된 경우가 더 빠를까? 보통은 서브 쿼리가 들어가면 속도가 더 느려진다.  
아래 예시처럼 실제 시간 차이가 나는지 간단하게 확인해보았다. 현재 테이블 크기는 table1의 경우 약 4.2G로 다수의 `entity_id` 20년치 데이터가 들어있다.  
추가적으로 Query Plan을 함께 확인하여 쿼리 동작이 어떻게 이루어지는지 확인하였다.

[ 예시 ]
- table1, table2의 `entity_id`라는 칼럼을 기준으로 inner join
- 조인 대상을 서브쿼리로 적용하느냐에 따라 구분하여 실행

### join with sub query
```sql
SELECT base_date, table2.unique_id, agg_count FROM table1 
INNER JOIN ( select entity_id, unique_id from table2 
		  where entity_id in ('xxxx0', 'xxxx1', 'xxxx2', 'xxxx3', 'xxxx4', 'xxxx5', 'xxxx6', 'xxxx7', 'xxxx8', 'xxxx9', 'xxxx10', 'xxxx11', 'xxxx12', 'xxxx13', 'xxxx14', 'xxxx15', 'xxxx16', 'xxxx17', 'xxxx18', 'xxxx19', 'xxxx20', 'xxxx21', 'xxxx22', 'xxxx23', 'xxxx24', 'xxxx25', 'xxxx26', 'xxxx27', 'xxxx28', 'xxxx29', 'xxxx30', 'xxxx31', 'xxxx32', 'xxxx33', 'xxxx34', 'xxxx35', 'xxxx36', 'xxxx37', 'xxxx38', 'xxxx39', 'xxxx40', 'xxxx41', 'xxxx42', 'xxxx43', 'xxxx44', 'xxxx45', 'xxxx46', 'xxxx47', 'xxxx48', 'xxxx49', 'xxxx50', 'xxxx51', 'xxxx52', 'xxxx53', 'xxxx54') ) table2
ON table1.entity_id = table2.entity_id 

/*
"Gather  (cost=600025.39..792357.91 rows=1257562 width=22)"
"  Workers Planned: 2"
"  ->  Parallel Hash Join  (cost=599025.39..665601.71 rows=523984 width=22)"
"        Hash Cond: (table2.entity_id = table1.entity_id)"
"        ->  Parallel Seq Scan on table2  (cost=0.00..12118.46 rows=337 width=17)"
"              Filter: (entity_id = ANY ('{xxxx0, xxxx1, xxxx2, xxxx3, xxxx4, xxxx5, xxxx6, xxxx7, xxxx8, xxxx9, xxxx10, xxxx11, xxxx12, xxxx13, xxxx14, xxxx15, xxxx16, xxxx17, xxxx18, xxxx19, xxxx20, xxxx21, xxxx22, xxxx23, xxxx24, xxxx25, xxxx26, xxxx27, xxxx28, xxxx29, xxxx30, xxxx31, xxxx32, xxxx33, xxxx34, xxxx35, xxxx36, xxxx37, xxxx38, xxxx39, xxxx40, xxxx41, xxxx42, xxxx43, xxxx44, xxxx45, xxxx46, xxxx47, xxxx48, xxxx49, xxxx50, xxxx51, xxxx52, xxxx53, xxxx54}'::bpchar[]))"
"        ->  Parallel Hash  (cost=433834.17..433834.17 rows=8997617 width=19)"
*/
```
```
Successfully run. Total query runtime: 19 secs 638 msec.
1472265 rows affected.
```
### join without sub query
```sql
SELECT base_date, table2.unique_id, agg_count FROM table1 
INNER JOIN table2 
ON table1.entity_id = table2.entity_id 
 WHERE table1.entity_id in ('xxxx0', 'xxxx1', 'xxxx2', 'xxxx3', 'xxxx4', 'xxxx5', 'xxxx6', 'xxxx7', 'xxxx8', 'xxxx9', 'xxxx10', 'xxxx11', 'xxxx12', 'xxxx13', 'xxxx14', 'xxxx15', 'xxxx16', 'xxxx17', 'xxxx18', 'xxxx19', 'xxxx20', 'xxxx21', 'xxxx22', 'xxxx23', 'xxxx24', 'xxxx25', 'xxxx26', 'xxxx27', 'xxxx28', 'xxxx29', 'xxxx30', 'xxxx31', 'xxxx32', 'xxxx33', 'xxxx34', 'xxxx35', 'xxxx36', 'xxxx37', 'xxxx38', 'xxxx39', 'xxxx40', 'xxxx41', 'xxxx42', 'xxxx43', 'xxxx44', 'xxxx45', 'xxxx46', 'xxxx47', 'xxxx48', 'xxxx49', 'xxxx50', 'xxxx51', 'xxxx52', 'xxxx53', 'xxxx54')

/*
"Gather  (cost=6680.84..358967.87 rows=74263 width=22)"
"  Workers Planned: 6"
"  ->  Parallel Hash Join  (cost=5680.84..350541.57 rows=12377 width=22)"
"        Hash Cond: (table1.entity_id = table2.entity_id)"
"        ->  Parallel Index Scan using table1_pkey on table1  (cost=0.56..344723.63 rows=1565 width=19)"
"              Index Cond: ((base_date >= '2000-01-01 00:00:00'::timestamp without time zone) AND (base_date <= '2005-06-30 00:00:00'::timestamp without time zone))"
"              Filter: (entity_id = ANY ('{xxxx0, xxxx1, xxxx2, xxxx3, xxxx4, xxxx5, xxxx6, xxxx7, xxxx8, xxxx9, xxxx10, xxxx11, xxxx12, xxxx13, xxxx14, xxxx15, xxxx16, xxxx17, xxxx18, xxxx19, xxxx20, xxxx21, xxxx22, xxxx23, xxxx24, xxxx25, xxxx26, xxxx27, xxxx28, xxxx29, xxxx30, xxxx31, xxxx32, xxxx33, xxxx34, xxxx35, xxxx36, xxxx37, xxxx38, xxxx39, xxxx40, xxxx41, xxxx42, xxxx43, xxxx44, xxxx45, xxxx46, xxxx47, xxxx48, xxxx49, xxxx50, xxxx51, xxxx52, xxxx53, xxxx54}'::bpchar[]))"
"        ->  Parallel Hash  (cost=4249.57..4249.57 rows=114457 width=17)"
"              ->  Parallel Seq Scan on table2  (cost=0.00..4249.57 rows=114457 width=17)"
*/
```
```
Successfully run. Total query runtime: 12 secs 407 msec.
1472265 rows affected.
```

요약하면..
- sub query 없이 join하는게 더 빠름
- filter의 역할이 중요하게 작동함( 전체 entity_id 18377개인데 55개( 0.3% )에 해당하는 경우만 추출하도록 하여 Index Scan이 효과적으로 적용됨 )
- filter의 역할이 미미해질 경우( 전체 테이블에서 큰 비율로 데이터를 로드해야 하는 경우,..) Seq Scan이 적용될 것(Parallel Seq Scan 인 경우 프로세스를 여러 개 띄워 병렬로 쿼리를 수행하나 CPU 사용량이 급증할 수 있음)

결과적으로 왠만하면 서브 쿼리는 적용하지 않는게 나을 것 같다..!