---
title: "21.07.05"
category: "til"
---
## [ PostgreSQL ] NUMERIC data type
출처: https://www.geeksforgeeks.org/postgresql-numeric-data-type/

postgresql에서  `NUMERIC` type이 지원된다. syntax는 아래와 같다. 

```sql
NUMERIC(precision, scale)

/*
Precision: 전체 숫자 길이
Scale: fraction( 소숫점 )의 길이
*
```
예를 들어,

```sql
CREATE TABLE IF NOT EXISTS products (
    id serial PRIMARY KEY,
    name VARCHAR NOT NULL,
    price NUMERIC (5, 2)
);
```
테이블을 생성하면, 아래와 같은 데이터를 삽입할 때
```sql
INSERT INTO products (name, price)
VALUES
    ('Phone', 100.2157), 
    ('Tablet', 300.2149);
```
[ 결과 ]
```sql
id | name  | price
-------------------
 1 | Phone | 100.22
 2 | Table | 300.21
```
전체 길이 5에서 소숫점 2만큼만 반영된다.

## [ Error ] 
### TypeError: ufunc 'isnan' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''
```python
df[column1].apply(lambda x: np.isnan(x))
# df[column1] dtype : object
```
에서 발생한 오류

출처: https://stackoverflow.com/questions/36000993/numpy-isnan-fails-on-an-array-of-floats-from-pandas-dataframe-apply/36001292 
> np.isnan can be applied to NumPy arrays of native dtype (such as np.float64)

> Since you have Pandas, you could use pd.isnull instead -- it can accept NumPy arrays of object or native dtypes

`pd.isnull` 로 적용하여 해결

## [ PostgreSQL ] inner join vs. pandas.merge(how='inner')
Postgresql 서버에서 inner join을 적용하는게 나을지, python에서 데이터를 메모리에 올려 `pandas.merge`로 적용하는게 나을지 실험해보았다. 데이터를 전구간으로 한번에 쿼리 요청하면 프로세스가 죽어있는 경우가 발생하여 연도별로 나눠서 받았다.

결과는 약 2배 차이 발생했다.
- `inner join` : 9172 sec
- `pd.merge` : 4060 sec